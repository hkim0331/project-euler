(ns hkim0331.p61
  (:require [clojure.math.combinatorics :as combo]))

; under construction

; Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

; Triangle    P3[n]=n(n+1)/2   1, 3, 6, 10, 15, ...
; Square      P4[n]=n^2        1, 4, 9, 16, 25, ...
; Pentagonal  P5[n]=n(3n−1)/2  1, 5, 12, 22, 35, ...
; Hexagonal   P6[n]=n(2n−1)    1, 6, 15, 28, 45, ...
; Heptagonal  P7[n]=n(5n−3)/2  1, 7, 18, 34, 55, ...
; Octagonal   P8[n]=n(3n−2)    1, 8, 21, 40, 65, ...
;
; The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

; The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
; Each polygonal type: triangle (P3[127]=8128), square (P4[91]=8281), and pentagonal (P5[44]=2882), is represented by a different number in the set.
; This is the only set of 4-digit numbers with this property.

; Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

(defn p3 [n] (/ (* n (+ n 1)) 2))

;(take 5 (map p3 (iterate inc 1)))

(defn p4 [n] (* n n))

;(take 5 (map p4 (iterate inc 1)))

(defn p5 [n] (/ (* n (- (* 3 n) 1)) 2))

;(take 5 (map p5 (iterate inc 1)))

(defn p6 [n] (* n (- (* 2 n) 1)))

;(take 5 (map p6 (iterate inc 1)))

(defn p7 [n] (/ (* n (- (* 5 n) 3)) 2))

;(take 5 (map p7 (iterate inc 1)))

(defn p8 [n] (* n (- (* 3 n) 2)))

;(take 40 (map p8 (iterate inc 1)))

(defn qm [n]
  "整数 n を上位2桁と下位二桁に分け、ベクタで返す。
  (qm 1234) => [12 34]"
 [(quot n 100) (mod n 100)])

(defn rng
  "f[n] となる4桁の整数。
  10 の位が 0 だと題意を満たさないので削除する。効くか？"
  [f]
  (map qm
    (remove #(< (mod % 100) 10)
            (take-while #(< % 10000)
              (drop-while #(< % 1000) (map f (iterate inc 1)))))))


(def gons [(rng p3) (rng p4) (rng p5) (rng p6) (rng p7) (rng p8)])
(def orders (combo/permutations [1 2 3 4 5]))

(def not-empty? (complement empty?))
;(not-empty? [])

(defn dfs

  "深さ優先探索。LISP 族は意識して書かないと幅優先探索になる。
   pi, pj, pk... の順に p60 をみたす [n m] をつないでいく。
   i, j, k... は [1 2 3 4 5] の順列を与える。
   答えを一つ見つけたら終わる。"

  [s order ret]
  (if (= 6 (count ret))
    (if (= (ffirst ret) (second (last ret)))
      ret
      nil)
    (when-let [founds (and (not-empty? order)
                           (filter #(= (second s) (first %))
                                   (gons (first order))))]
      (filter not-empty?
              (for [f founds]
                (dfs f (rest order) (conj ret f)))))))

(first
  (filter not-empty?
    (for [f (first gons) o orders]
      (dfs f o [f]))))

; (time
;  (first
;    (filter not-empty?
;      (for [f (first gons) o orders]
;           (dfs f o [f])))))
; "Elapsed time: 179.300439 msecs"
; ((((([[82 56] [56 25] [25 12] [12 81] [81 28] [28 82]])))))
; (+ 8256 5625 2512 1281 8128 2882)
